# methods for generating annotated tei
from datetime import datetime
from django.contrib.auth import get_user_model
from django.db.models import Q
from django.utils.text import slugify
from eulxml.xmlmap import load_xmlobject_from_string, teimap
import logging
from lxml import etree
import mistune

from readux import __version__
from readux.books import tei, markdown_tei
from readux.utils import absolutize_url


logger = logging.getLogger(__name__)


def annotated_tei(teivol, annotations):
    # iterate throuth the annotations associated with this volume
    # and insert them into the tei based on the content they reference

    # perhaps some sanity-checking: compare annotation total vs
    # number actually added as we go page-by-page?

    tags = set()
    # make sure tei xml is using the xmlobject we need to add
    # annotation data and tags
    if not isinstance(teivol, tei.AnnotatedFacsimile):
        teivol = tei.AnnotatedFacsimile(teivol.node)

    # update title to reflect annotated version being exported
    teivol.main_title = teivol.title
    teivol.subtitle = ", an annotated digital edition"
    del teivol.title  # delete old, unqualified title

    # update responsibility statement
    teivol.responsibility = 'annotated by'
    # get a distinct list of all annotation authors
    user_ids = annotations.only('user').order_by('user')\
                       .values_list('user', flat=True).distinct()
    users = get_user_model().objects.filter(id__in=user_ids)
    for user in users:
        teivol.responsible_names.append(tei.Name(id=user.username,
                                                 value=user.get_full_name()))

    # publication statement - main info should already be set
    # update to reflect annotated tei and ensure date is current
    teivol.pubstmt.desc = 'Annotated TEI generated by Readux version %s' % __version__
    export_date = datetime.now()
    teivol.pubstmt.date = export_date
    teivol.pubstmt.date_normal = export_date

    for page in teivol.page_list:
        # NOTE: page.href could either be local readux uri OR ARK uri;
        # local uri is stored as annotation uri, but ark is in extra data
        page_annotations = annotations.filter(Q(uri=page.href)|Q(extra_data__contains=page.href))
        if page_annotations.exists():
            for note in page_annotations:
                insert_note(teivol, page, note)
                # collect a list of unique tags as we work through the notes
                if 'tags' in note.info():
                    tags |= set(t.strip() for t in note.info()['tags'])

    # tags are included in the back matter as an interpGrp
    if tags:
        # create back matter interpgrp for annotation tags
        teivol.create_tags()
        for tag in tags:
            # NOTE: our tag implementation currently does not allow spaces,
            # but using slugify to generate ids to avoid any issues with spaces
            # and variation in capitalization or punctuation
            teivol.tags.interp.append(tei.Interp(id=slugify(tag), value=tag))

    return teivol


def annotation_to_tei(annotation):
    'Generate a tei note from an annotation'
    # NOTE: annotation created/edited dates are not included here
    # because they were determined not to be relevant for our purposes

    # sample note provided by Alice
    # <note resp="JPK" xml:id="oshnp50n1" n="1"><p>This is an example note.</p></note>

    # convert markdown-formatted text content to tei
    note_content = markdown_tei.convert(annotation.text)
    # markdown results could be a list of paragraphs, and not a proper
    # xml tree; also, pags do not include namespace
    # wrap in a note element and set the default namespace as tei
    teinote = load_xmlobject_from_string('<note xmlns="%s">%s</note>' % \
        (teimap.TEI_NAMESPACE, note_content),
        tei.Note)

    # what id do we want? annotation uuid? url?
    teinote.id = 'annotation-%s' % annotation.id  # can't start with numeric
    teinote.href = absolutize_url(annotation.get_absolute_url())
    teinote.type = 'annotation'

    # if an annotation includes tags, reference them by slugified id in @ana
    if 'tags' in annotation.info() and annotation.info()['tags']:
        tags = ' '.join(set('#%s' % slugify(t.strip())
                            for t in annotation.info()['tags']))
        teinote.ana = tags

    # if the annotation has an associated user, mark the author
    # as responsible for the note
    if annotation.user:
        teinote.resp = annotation.user.username

    return teinote

def html_xpath_to_tei(xpath):
    # convert xpaths generated on the readux site to the
    # equivalent xpaths for the corresponding tei content
    # NOTE: span could match either line in abbyy ocr or word in mets/alto
    return xpath.replace('div', 'tei:zone') \
                .replace('span', 'node()[local-name()="line" or local-name()="w"]') \
                .replace('@id', '@xml:id')

def insert_note(teivol, teipage, annotation):

    info = annotation.info()
    # convert html xpaths to tei
    if info['ranges']:
        # NOTE: assuming a single range selection for now
        # the annotator model supports multiple, but UI does not currently
        # support it.
        selection_range = info['ranges'][0]
        # convert html xpaths from readux website to equivalent tei xpaths
        # for selection within the facsimile document
        # either of start or end xpaths could be empty; if so, assume
        # starting at the beginning of the page or end at the end
        start_xpath = html_xpath_to_tei(selection_range['start']) or '//tei:zone[1]'
        end_xpath = html_xpath_to_tei(selection_range['end']) or '//tei:zone[last()]'
        # insert references using start and end xpaths & offsets
        start = teipage.node.xpath(start_xpath, namespaces=tei.Zone.ROOT_NAMESPACES)
        end = teipage.node.xpath(end_xpath, namespaces=tei.Zone.ROOT_NAMESPACES)
        if not start or not end:
            logger.warn('Could not find start or end xpath for annotation %s' % annotation.id)
            return
        else:
            # xpath returns a list of matches; we only want the first one
            start = start[0]
            end = end[0]

        start_anchor = tei.Anchor(type='text-annotation-highlight-start',
            id='highlight-start-%s' % annotation.id)
        end_anchor = tei.Anchor(type='text-annotation-highlight-end',
            id='highlight-end-%s' % annotation.id)

        # insert the end *first* in case start and end are in the
        # same element; otherwise, the offsets get mixed up
        insert_anchor(end, end_anchor.node, selection_range['endOffset'])
        insert_anchor(start, start_anchor.node, selection_range['startOffset'])

        # generate range target for the note element
        target = '#range(#%s, #%s)' % (start_anchor.id, end_anchor.id)

    elif 'image_selection' in info:
        # for readux, image annotation can *only* be the page image
        # so not checking image uri
        page_width = teipage.lrx - teipage.ulx
        page_height = teipage.lry - teipage.uly

        # create a new zone for the image highlight
        image_highlight = tei.Zone(type="image-annotation-highlight")
        # image selection in annotation stored as percentages
        # convert ##% into a float that can be multiplied by page dimensions
        selection = {
            'x': float(info['image_selection']['x'].rstrip('%')) / 100,
            'y': float(info['image_selection']['y'].rstrip('%')) / 100,
            'w': float(info['image_selection']['w'].rstrip('%')) / 100,
            'h': float(info['image_selection']['h'].rstrip('%')) / 100
        }

        # convert percentages into upper left and lower right coordinates
        # relative to the page
        image_highlight.ulx = selection['x'] * float(page_width)
        image_highlight.uly = selection['y'] * float(page_height)
        image_highlight.lrx = image_highlight.ulx + (selection['w'] * page_width)
        image_highlight.lry = image_highlight.uly + (selection['h'] * page_height)

        image_highlight.id = 'highlight-%s' % annotation.id
        target = '#%s' % image_highlight.id

        teipage.node.append(image_highlight.node)

    # call annotation_to_tei and insert the resulting note into
    # the appropriate part of the document
    teinote = annotation_to_tei(annotation)
    teinote.target = target
    # append actual annotation to tei annotations div
    teivol.annotations.append(teinote)


def insert_anchor(el, anchor, offset):
    # insert an anchor into an element at a given offset
    if offset == 0:
        # offset zero - insert directly before this element
        el.addprevious(anchor)
    elif offset >= len(el.text):
        # offset at end of this element - insert directly after
        el.addnext(anchor)
    else:
        # offset somewhere inside the text of this element
        # insert the element after the text and then break up
        # the lxml text and "tail" so that text after the offset
        # comes after the inserted anchor
        el_text = el.text
        el.insert(0, anchor)
        el.text = el_text[:offset]
        anchor.tail = el_text[offset:]


